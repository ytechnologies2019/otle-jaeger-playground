{"version":3,"file":"propwrap.js","sourceRoot":"","sources":["../../src/propwrap.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * This block is derived from esbuild's bundling support.\n * https://github.com/evanw/esbuild/blob/v0.14.42/internal/runtime/runtime.go#L22\n *\n * License:\n * MIT License\n *\n * Copyright (c) 2020 Evan Wallace\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nconst __defProp = Object.defineProperty;\nconst __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nconst __hasOwnProp = Object.prototype.hasOwnProperty;\nconst __getOwnPropNames = Object.getOwnPropertyNames;\nconst __copyProps = (\n  to: any,\n  from: any,\n  except: string,\n  desc?: PropertyDescriptor | undefined\n) => {\n  if ((from && typeof from === 'object') || typeof from === 'function') {\n    for (const key of __getOwnPropNames(from)) {\n      if (!__hasOwnProp.call(to, key) && key !== except) {\n        __defProp(to, key, {\n          get: () => from[key] as any,\n          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,\n        });\n      }\n    }\n  }\n  return to;\n};\n\n/**\n * Return a new object that is a copy of `obj`, with its `subpath` property\n * replaced with the return value of `wrapper(original)`.\n *\n * This is similar to shimmer (i.e. `InstrumentationBase.prototype._wrap`).\n * However, it uses a different technique to support wrapping properties that\n * are only available via a getter (i.e. their property descriptor is `.writable\n * === false`).\n *\n * For example:\n *    var os = propwrap(require('os'), 'platform', (orig) => {\n *      return function wrappedPlatform () {\n *        return orig().toUpperCase()\n *      }\n *    })\n *    console.log(os.platform()) // => DARWIN\n *\n * The subpath can indicate a nested property. Each property in that subpath,\n * except the last, must identify an *Object*.\n *\n * Limitations:\n * - This doesn't handle possible Symbol properties on the copied object(s).\n * - This cannot wrap a property of a function, because we cannot create a\n *   copy of the function.\n *\n * @param {object} obj\n * @param {string} subpath - The property subpath on `obj` to wrap. This may\n *    point to a nested property by using a '.' to separate levels. For example:\n *        var fs = wrap(fs, 'promises.sync', (orig) => { ... })\n * @param {Function} wrapper - A function of the form `function (orig)`, where\n *    `orig` is the original property value. This must synchronously return the\n *    new property value.\n * @returns {object} A new object with the wrapped property.\n * @throws {TypeError} if the subpath points to a non-existent property, or if\n *    any but the last subpath part points to a non-Object.\n */\nexport const propwrap = (obj: any, subpath: string, wrapper: Function): any => {\n  const parts = subpath.split('.');\n  const namespaces = [obj];\n  let namespace = obj;\n  let key;\n  let val;\n\n  // 1. Traverse the subpath parts to sanity check and get references to the\n  //    Objects that we will be copying.\n  for (let i = 0; i < parts.length; i++) {\n    key = parts[i];\n    val = namespace[key];\n    if (!val) {\n      throw new TypeError(\n        `cannot wrap \"${subpath}\": \"<obj>.${parts\n          .slice(0, i)\n          .join('.')}\" is ${typeof val}`\n      );\n    } else if (i < parts.length - 1) {\n      if (typeof val !== 'object') {\n        throw new TypeError(\n          `cannot wrap \"${subpath}\": \"<obj>.${parts\n            .slice(0, i)\n            .join('.')}\" is not an Object`\n        );\n      }\n      namespace = val;\n      namespaces.push(namespace);\n    }\n  }\n\n  // 2. Now work backwards, wrapping each namespace with a new object that has a\n  //    copy of all the properties, except the one that we've wrapped.\n  for (let i = parts.length - 1; i >= 0; i--) {\n    key = parts[i];\n    namespace = namespaces[i];\n    if (i === parts.length - 1) {\n      const orig = namespace[key];\n      val = wrapper(orig);\n    } else {\n      val = namespaces[i + 1];\n    }\n    const desc = __getOwnPropDesc(namespace, key);\n    const wrappedNamespace = __defProp({}, key, {\n      value: val,\n      enumerable: !desc || desc.enumerable,\n    });\n    __copyProps(wrappedNamespace, namespace, key);\n    namespaces[i] = wrappedNamespace;\n  }\n\n  return namespaces[0];\n};\n"]}